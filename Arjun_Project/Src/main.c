/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stdint.h>
#define peripheralbaseaddress 		(0x40000000UL)  //identify the base of programmable memory
#define AHB1_OFFSET 				(0X00020000UL) //IDENTIFY THE ADDRESS OF BUS
#define AHB1_BASEADDRESS 			(peripheralbaseaddress + AHB1_OFFSET) //DEFINE AHB1 BASE ADDRESS

#define RCC_OFFSET 					(0x00003800UL)//CLOCK ADDRESSING CONFIGURATION
#define AHB1_RCC 					(AHB1_BASEADDRESS+ RCC_OFFSET)//

#define GPIOA_OFFSET 				(0X00000000UL ) //DEFINE GPIOA OFFSET
#define AHB1_GPIOA 					(AHB1_BASEADDRESS + GPIOA_OFFSET) // DEFINE GPIOA ADDRESS
#define GPIOB_OFFSET 				(0x00000400UL)
#define AHB1_GPIOB 					(AHB1_BASEADDRESS + GPIOB_OFFSET)//GPIOB ADDRESS DEFINE

typedef struct{
	uint32_t MODER;
	uint32_t OTYPER;
	uint32_t OSPEEDR;
	uint32_t PUPDR;
	uint32_t IDR;
	uint32_t ODR;
	uint32_t BSRR;
	uint32_t LCKR;
	uint32_t AFRL;
	uint32_t AFRH;
} GPIOA_REGISTER;

typedef struct{
	uint32_t MODER;
	uint32_t OTYPER;
	uint32_t OSPEEDR;
	uint32_t PUPDR;
	uint32_t IDR;
	uint32_t ODR;
	uint32_t BSRR;
	uint32_t LCKR;
	uint32_t AFRL;
	uint32_t AFRH;
} GPIOB_REGISTER;

typedef struct{
	uint32_t CR;
	uint32_t PLLCFGR;
	uint32_t CFGR;
	uint32_t CIR;
	uint32_t AHB1STR;
	uint32_t AHB2STR;
	uint32_t RESERVED1[2];
	uint32_t APB1RSTR;
	uint32_t APB2RSTR;
	uint32_t RESERVED2[2];
	uint32_t AHB1ENR;
	uint32_t AHB2ENR;
	uint32_t RESERVED3[2];
	uint32_t APB1ENR;
	uint32_t APB2ENR;
	uint32_t RESERVED4[2];
	uint32_t AHB1LPENR;
	uint32_t AHB2LPENR;
	uint32_t RESERVED5[2];
	uint32_t APB1LPENR;
	uint32_t APB2LPENR;
	uint32_t RESERRVED6[2];
	uint32_t BDCR;
	uint32_t CSR;
	uint32_t RESERVEDD7[2];
	uint32_t SSCGR;
	uint32_t PLLI2SCFGR;
	uint32_t DCKCFGR;
} RCC_REGISTER;

#define GPIOA  ((GPIOA_REGISTER*) AHB1_GPIOA)//
#define GPIOB  ((GPIOB_REGISTER*) AHB1_GPIOB)//
#define RCC  ((RCC_REGISTER*) AHB1_RCC)

int main(void)
{
	RCC -> AHB1ENR |= (1U<<0);// We enabled the AHB1 Clock Access for GPIO A
	GPIOA -> MODER |= (1U<<0);// We setup PA0 as OUTPUT
	GPIOA -> MODER |= (1U<<2);// We setup PA1 as OUTPUT
	GPIOA -> MODER |= (1U<<4);// We setup PA2 as OUTPUT
	GPIOA -> MODER |= (1U<<6);// We setup PA3 as OUTPUT
	GPIOA -> MODER |= (1U<<8);// We setup PA4 as OUTPUT
	GPIOA -> MODER |= (1U<<10);// We setup PA5 as OUTPUT
	GPIOA -> MODER |= (1U<<12);// We setup PA6 as OUTPUT
	GPIOA -> MODER |= (1U<<14);// We setup PA7 as OUTPUT
	GPIOA -> MODER |= (1U<<16);// We setup PA8 as OUTPUT
	GPIOA -> MODER |= (1U<<18);// We setup PA9 as OUTPUT
	GPIOA -> MODER |= (1U<<20);// We setup PA10 as OUTPUT
	GPIOA -> MODER |= (1U<<22);// We setup PA11 as OUTPUT
	GPIOA -> MODER |= (1U<<24);// We setup PA12 as OUTPUT
	GPIOA -> MODER |= (1U<<26);// We setup PA13 as OUTPUT
	GPIOA -> MODER &= ~(1U<<27);// We setup PA13 as OUTPUT
	GPIOA -> MODER |= (1U<<28);// We setup PA14 as OUTPUT
	GPIOA -> MODER &= ~(1U<<29);// We setup PA14 as OUTPUT
	GPIOA -> MODER |= (1U<<30);// We setup PA15 as OUTPUT
	GPIOA -> MODER &= ~(1U<<31);// We setup PA14 as OUTPUT
	/* GPIOB SETUP */
	RCC -> AHB1ENR |= (1U<<1);// We enabled the AHB1 Clock Access for GPIO B
	GPIOB -> MODER |= (1U<<0);// We setup PB0 as OUTPUT
	GPIOB -> MODER |= (1U<<2);// We setup PB1 as OUTPUT
	GPIOB -> MODER |= (1U<<4);// We setup PB2 as OUTPUT
	GPIOB -> MODER |= (1U<<6);// We setup PB3 as OUTPUT
	GPIOB -> MODER &= ~(1U<<7);// We setup PB3 as OUTPUT
	GPIOB -> MODER |= (1U<<8);// We setup PB4 as OUTPUT
	GPIOB -> MODER &= ~(1U<<9);// We setup PB4 as OUTPUT
	GPIOB -> MODER |= (1U<<10);// We setupPB5 as OUTPUT
	GPIOB -> MODER |= (1U<<12);// We setup PB6 as OUTPUT
	GPIOB -> MODER |= (1U<<14);// We setup PB7 as OUTPUT
	while(1)
	{
		GPIOA -> ODR ^= (1U<<0);
		for(long i = 0; i<800000; i = i+1);
		GPIOA -> ODR ^= (1U<<1);
		for(long i = 0; i<800000; i = i+1);
		GPIOA -> ODR ^= (1U<<2);
		for(long i = 0; i<800000; i = i+1);
		GPIOA -> ODR ^= (1U<<3);
		for(long i = 0; i<800000; i = i+1);
		GPIOA -> ODR ^= (1U<<4);
		for(long i = 0; i<800000; i = i+1);
		GPIOA -> ODR ^= (1U<<5);
		for(long i = 0; i<800000; i = i+1);
		GPIOA -> ODR ^= (1U<<6);
		for(long i = 0; i<800000; i = i+1);
		GPIOA -> ODR ^= (1U<<7);
		for(long i = 0; i<800000; i = i+1);
		GPIOA -> ODR ^= (1U<<8);
		for(long i = 0; i<800000; i = i+1);
		GPIOA -> ODR ^= (1U<<9);
		for(long i = 0; i<800000; i = i+1);
		GPIOA -> ODR ^= (1U<<10);
		for(long i = 0; i<800000; i = i+1);
		GPIOA -> ODR ^= (1U<<11);
		for(long i = 0; i<800000; i = i+1);
		GPIOA -> ODR ^= (1U<<12);
		for(long i = 0; i<800000; i = i+1);
		GPIOA -> ODR ^= (1U<<13);
		for(long i = 0; i<800000; i = i+1);
		GPIOA -> ODR ^= (1U<<14);
		for(long i = 0; i<800000; i = i+1);
		GPIOA -> ODR ^= (1U<<15);
		for(long i = 0; i<800000; i = i+1);
		GPIOB -> ODR ^= (1U<<0);
		for(long i = 0; i<800000; i = i+1);
		GPIOB -> ODR ^= (1U<<1);
		for(long i = 0; i<800000; i = i+1);
		GPIOB -> ODR ^= (1U<<2);
		for(long i = 0; i<800000; i = i+1);
		GPIOB -> ODR ^= (1U<<3);
		for(long i = 0; i<800000; i = i+1);
		GPIOB -> ODR ^= (1U<<4);
		for(long i = 0; i<800000; i = i+1);
		GPIOB -> ODR ^= (1U<<5);
		for(long i = 0; i<800000; i = i+1);
		GPIOB -> ODR ^= (1U<<6);
		for(long i = 0; i<800000; i = i+1);
		GPIOB -> ODR ^= (1U<<7);
		for(long i = 0; i<800000; i = i+1);
	}
}
